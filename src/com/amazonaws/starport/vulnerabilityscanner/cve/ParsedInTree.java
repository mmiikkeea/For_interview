// Assume can get the operator and app at the same nodelist

package com.amazonaws.starport.vulnerabilityscanner.cve;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.stream.XMLStreamException;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

import com.amazonaws.starport.vulnerabilityscanner.model.ApplicationModel;
import com.amazonaws.starport.vulnerabilityscanner.model.LogicTestTreeNode;
import com.amazonaws.starport.vulnerabilityscanner.model.NewXmlModel;

public class ParsedInTree {
    static int levelCounter = 0;

    public static void main(final String args[]) throws XMLStreamException,
            SAXException, IOException, ParserConfigurationException {
        final ParsedInTree xmlp = new ParsedInTree();

        xmlp.parsedCve("CVEfolder/nvdTest.xml");
    }

    public List<NewXmlModel> parsedCve(final String fileName)
            throws SAXException, IOException, ParserConfigurationException {
        final DocumentBuilderFactory dbFactory = DocumentBuilderFactory
                .newInstance();
        final Document doc = dbFactory.newDocumentBuilder().parse(
                new File(fileName));
        doc.getDocumentElement().normalize();
        final NodeList cveidNodeList = doc.getElementsByTagName("entry");
        return getCveApp(cveidNodeList);
    }

    private static List<NewXmlModel> getCveApp(final NodeList entryNodeList)
            throws FileNotFoundException, UnsupportedEncodingException {
        String cveid = null;
        String score = null;
        String summary = null;
        final List<NewXmlModel> nvdList = new ArrayList<>();
        final List<String> osList = new ArrayList<>();
        final List<LogicTestTreeNode> children = new ArrayList<>();
        // make all of the app into application model
        ApplicationModel value = new ApplicationModel("", "");
        final List<List<ApplicationModel>> treeResult = new ArrayList<>();
        LogicTestTreeNode root = new LogicTestTreeNode(children, value);
        for (int j = 0; j < entryNodeList.getLength(); j++) {
            NewXmlModel xmlModel = null;
            final Element cveElement = (Element) entryNodeList.item(j);
            summary = cveElement.getElementsByTagName("vuln:summary").item(0)
                    .getTextContent();
            if (cveElement.getAttribute("id") != null) {
                cveid = cveElement.getAttribute("id");
            }
            final NodeList childNodeList = entryNodeList.item(j)
                    .getChildNodes();
            for (int i = 0; i < childNodeList.getLength(); i++) {
                if (childNodeList.item(i).getNodeType() == Node.ELEMENT_NODE) {
                    final Node secondNode = childNodeList.item(i);
                    final Element secondElement = (Element) secondNode;
                    try {
                        score = secondElement
                                .getElementsByTagName("cvss:score").item(0)
                                .getTextContent();
                    } catch (final Exception e) {
                    }
                }
                final NodeList thirdNodeList = childNodeList.item(i)
                        .getChildNodes();

                for (int k = 0; k < thirdNodeList.getLength(); k++) {
                    try {
                        final String operator = thirdNodeList.item(k)
                                .getAttributes().getNamedItem("operator")
                                .getNodeValue();
                        if ("AND".equals(operator)) {
                            final List<LogicTestTreeNode> child = new ArrayList<>();
                            child.addAll(handleNextLevel(thirdNodeList.item(k)));
                            value = new ApplicationModel("AND", "");
                            root = new LogicTestTreeNode(child, value);
                        } else if ("OR".equals(operator)) {
                            final List<LogicTestTreeNode> child = new ArrayList<>();
                            child.addAll(handleNextLevel(thirdNodeList.item(k)));
                            value = new ApplicationModel("OR", "");
                            root = new LogicTestTreeNode(child, value);
                        }
                    } catch (final Exception e) {
                    }
                }
            }

            final List<ApplicationModel> postOrderTraversal = postOrderTraversal(root);
            treeResult.add(postOrderTraversal);
            xmlModel = new NewXmlModel(cveid, summary, osList, score,
                    postOrderTraversal);
            nvdList.add(xmlModel);
        }
        return nvdList;
    }

    private static List<LogicTestTreeNode> handleNextLevel(final Node node) {
        final NodeList nodeList = node.getChildNodes();
        final List<LogicTestTreeNode> noChild = new ArrayList<>();
        final List<LogicTestTreeNode> children = new ArrayList<>();
        LogicTestTreeNode parent;
        ApplicationModel applicationModel;
        List<LogicTestTreeNode> nextChildren;

        for (int x = 0; x < nodeList.getLength(); x++) {
            String operator = "";
            String negate = "";
            try {
                operator = nodeList.item(x).getAttributes()
                        .getNamedItem("operator").getNodeValue();
                negate = nodeList.item(x).getAttributes()
                        .getNamedItem("negate").getNodeValue();
            } catch (final Exception e) {
            }
            String app = null;
            try {
                app = nodeList.item(x).getAttributes().getNamedItem("name")
                        .getNodeValue();
            } catch (final Exception e) {
            }
            if (app != null && isApplication(app)) {
                applicationModel = new ApplicationModel(app.split(":")[3],
                        app.split(":")[4]);
                final LogicTestTreeNode child = new LogicTestTreeNode(noChild,
                        applicationModel);
                children.add(child);
            }
            if ("AND".equals(operator)) {
                if ("true".equals(negate)) {
                    nextChildren = handleNextLevel(nodeList.item(x));
                    applicationModel = new ApplicationModel("AndNegate", "");
                } else {
                    nextChildren = handleNextLevel(nodeList.item(x));
                    applicationModel = new ApplicationModel("AND", "");
                }
                parent = new LogicTestTreeNode(nextChildren, applicationModel);
                children.add(parent);
            } else if ("OR".equals(operator)) {
                if ("true".equals(negate)) {
                    nextChildren = handleNextLevel(nodeList.item(x));
                    applicationModel = new ApplicationModel("OrNegate", "");
                } else {
                    nextChildren = handleNextLevel(nodeList.item(x));
                    applicationModel = new ApplicationModel("OR", "");
                }
                parent = new LogicTestTreeNode(nextChildren, applicationModel);
                children.add(parent);
            }
        }
        return children;
    }

    private static boolean isApplication(final String appName) {
        if (appName.startsWith("cpe:/a") || appName.startsWith("cpe:/o")) {
            return true;
        } else
            return false;
    }

    public static List<ApplicationModel> postOrderTraversal(
            final LogicTestTreeNode root) {
        final List<ApplicationModel> appLogicTestResult = new ArrayList<>();
        final List<LogicTestTreeNode> children = new ArrayList<>();
        final ApplicationModel sep1 = new ApplicationModel("(", "");
        final LogicTestTreeNode separateIcon1 = new LogicTestTreeNode(children,
                sep1);
        if (root == null) {
            return null;
        }
        final Stack<LogicTestTreeNode> stack = new Stack<>();
        stack.push(root);
        while (!stack.isEmpty()) {
            final LogicTestTreeNode temp = stack.peek();
            if (temp.getChildren().isEmpty()) {
                final LogicTestTreeNode pop = stack.pop();
                appLogicTestResult.add(pop.getValue());
            } else {
                stack.push(temp.getChildren().get(0));
                if (!"OR".equals(temp.getValue().getApplicationName())
                        || !"AND".equals(temp.getValue().getApplicationName())) {
                    stack.push(separateIcon1);
                }
                temp.getChildren().remove(0);
            }
        }
        return appLogicTestResult;
    }

    // Below two function are for checking if postorder and tree are built
    // correctly
    public static List<List<ApplicationModel>> levelOrder(
            final LogicTestTreeNode root) {
        final List<List<ApplicationModel>> levelOrderResult = new ArrayList<>();
        ArrayList<ApplicationModel> nodeValues = new ArrayList<>();
        List<LogicTestTreeNode> current = new ArrayList<LogicTestTreeNode>();
        List<LogicTestTreeNode> next = new ArrayList<LogicTestTreeNode>();
        current.add(root);
        if (root == null) {
            return null;
        }
        while (!current.isEmpty()) {
            final LogicTestTreeNode node = current.remove(0);
            if (!node.getChildren().isEmpty()) {
                next.addAll(node.getChildren());
            }
            nodeValues.add(node.getValue());
            if (current.isEmpty()) {
                current = next;
                next = new ArrayList<>();
                levelOrderResult.add(nodeValues);
                nodeValues = new ArrayList<>();
            }
        }
        return levelOrderResult;
    }

    public static List<ApplicationModel> preOrderTraversal(
            final LogicTestTreeNode root) {
        final List<ApplicationModel> appLogicTestResult = new ArrayList<>();
        if (root == null)
            return null;
        appLogicTestResult.add(root.getValue());
        for (int i = 0; i < root.getChildren().size(); i++) {
            appLogicTestResult.addAll(preOrderTraversal(root.getChildren().get(
                    i)));
        }
        return appLogicTestResult;
    }
}
