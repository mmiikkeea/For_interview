package com.amazonaws.starport.vulnerabilityscanner.model;

import java.util.ArrayList;
import java.util.List;

import lombok.Value;

@Value
public class NewXmlModel {
    String cveId;
    String summary;
    List<String> osList;
    String score;
    List<ApplicationModel> allApps;

    public boolean affects(final List<ApplicationModel> imageApps) {
        boolean isVulnerable = false;
        System.out.println("Img:" + imageApps);
        System.out.println("Cve:" + allApps);

        final List<String> logicList = new ArrayList<>();
        String result = "";
        // turn the list into logic list
        try {
            for (int i = 0; i < allApps.size(); i++) {
                final ApplicationModel cveApp = allApps.get(i);
                if (cveApp.getApplicationName().equals("OR")
                        || cveApp.getApplicationName().equals("AND")) {
                    logicList.add(cveApp.getApplicationName());
                } else if (cveApp.getApplicationName().equals("(")) {
                    logicList.add(cveApp.getApplicationName());
                    continue;
                } else {
                    for (final ApplicationModel imageApp : imageApps) {
                        if (imageApp.cpeMatch(cveApp.getApplicationName(),
                                cveApp.getApplicationVersion())) {
                            result = "TRUE";
                            break;
                        } else {
                            result = "FALSE";
                        }
                    }
                    logicList.add(result);
                }
            }
        } catch (final Exception e) {
            System.out.println(e);
        }
        System.out.println("------After test------");
        System.out.println(logicList);
        isVulnerable = getResult(logicList);
        if (isVulnerable) {
            System.out.println("vulnerable");
        } else {
            System.out.println("safe");
        }
        return isVulnerable;
    }

    public boolean getResult(final List<String> logicList) {
        List<String> subTreelist = new ArrayList<>();
        final boolean isVulnerable;
        int headOfSubTree = 0;
        String result = null;
        for (int i = 0; i < logicList.size(); i++) {
            switch (logicList.get(i)) {
            default:
                // and,or,andnegate,ornegate...
                subTreelist.add(logicList.get(i));
                result = getResultOfSubTree(subTreelist);
                logicList.set(i, result);

                if (i < logicList.size()) {
                    logicList.subList(headOfSubTree, i).clear();
                    System.out.println("After clear " + logicList);
                    System.out.println("After clear " + logicList.size());
                    getResult(logicList);
                }
                break;
            case "(":
                if ("(".equals(logicList.get(i + 1))) {
                    headOfSubTree = i;
                    i = i + 1;
                    subTreelist = new ArrayList<>();
                }
                break;
            case "TRUE":
            case "FALSE":
                subTreelist.add(logicList.get(i));
                break;
            }
        }
        isVulnerable = "TRUE".equals(logicList.get(0)) ? true : false;
        return isVulnerable;
    }

    private String getResultOfSubTree(final List<String> subTreelist) {
        final String operator = subTreelist.get(subTreelist.size() - 1);
        String result = null;
        System.out.println("subTreelist");
        System.out.println(subTreelist);
        switch (operator) {
        case "AND":
            result = "TRUE";
            if (subTreelist.contains("FALSE")) {
                result = "FALSE";
            }
            break;
        case "OR":
            result = "FALSE";
            if (subTreelist.contains("TRUE")) {
                result = "TRUE";
            }
            break;
        case "AndNegate":
            result = "FALSE";
            if (subTreelist.contains("FALSE")) {
                result = "TRUE";
            }
            break;
        case "OrNegate":
            result = "TRUE";
            if (subTreelist.contains("TRUE")) {
                result = "FALSE";
            }
            break;
        }
        return result;
    }
}