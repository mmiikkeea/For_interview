package com.amazonaws.starport.vulnerabilityscanner.scanner;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import javax.xml.parsers.ParserConfigurationException;
import javax.xml.stream.XMLStreamException;

import lombok.NonNull;

import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mockito;
import org.mockito.runners.MockitoJUnitRunner;
import org.xml.sax.SAXException;

import com.amazonaws.starport.vulnerabilityscanner.cve.Identifier;
import com.amazonaws.starport.vulnerabilityscanner.cve.Parser;
import com.amazonaws.starport.vulnerabilityscanner.model.ApplicationModel;
import com.amazonaws.starport.vulnerabilityscanner.model.CveModel;
import com.amazonaws.starport.vulnerabilityscanner.model.LayerModel;

@RunWith(MockitoJUnitRunner.class)
public class ScannerTest {
    private static final String ImageDigest = "sha256:439f0491b0b116bd9f0cf648f932d37aaf892b396299c4652fb9567d4c529317";
    private static final String RepoName = "mysql0703";
    private static final String layerDigest = "sha:123";
    private static final String applicationName = "bash";
    private static final String applicationVersion = "4.2";
    private static final String imageOs = "";
    private static final String fileName = "CVEfolder/nvdcve-2.0-2014-partial.xml";

    private Scanner scanner;
    @NonNull
    private LayerModel layerModel;

    @NonNull
    private FrontendServiceWrapper frontendDoubleService;
    @NonNull
    private LayerRepository layerRepository;
    private Identifier cveIdentifier;
    private Parser cveParser;

    @Before
    public void setUp() throws Exception {
        frontendDoubleService = Mockito.mock(FrontendServiceWrapper.class);
        layerRepository = Mockito.mock(LayerRepository.class);
        cveParser = Mockito.mock(Parser.class);
        cveIdentifier = new Identifier(cveParser);
        scanner = new Scanner(frontendDoubleService, layerRepository,
                cveIdentifier);

        final List<CveModel> cves = new ArrayList<>();
        final CveModel cve = setCveModel();
        Mockito.when(cveParser.parsedCve(fileName)).thenReturn(cves);
        final List<String> layers = new ArrayList<>(Arrays.asList(layerDigest));
        Mockito.when(
                frontendDoubleService.getLayerByImage(ImageDigest, RepoName))
                .thenReturn(layers);
        final ApplicationModel app = new ApplicationModel(applicationName,
                applicationVersion);
        final List<ApplicationModel> apps = new ArrayList<ApplicationModel>(
                Arrays.asList(app));
        Mockito.when(layerRepository.getAppForLayer(layerDigest)).thenReturn(
                apps);

        Mockito.when(cveIdentifier.getCve(app, imageOs)).thenReturn(cves);
    }

    @Test
    public void shouldReturnTheCVEforTheLayer() throws IOException,
            XMLStreamException, SAXException, ParserConfigurationException {

        final CveModel cve = setCveModel();

        final List<CveModel> expected = new ArrayList<>();
        expected.add(cve);
        Assert.assertEquals(expected,
                scanner.getCVEForImage(ImageDigest, RepoName));
    }

    private CveModel setCveModel() {
        final String cveId = "CVE-2016-0729";
        final ApplicationModel app = new ApplicationModel(applicationName,
                applicationVersion);
        final List<ApplicationModel> appList = new ArrayList<>(
                Arrays.asList(app));
        final String summary = "This is a summary";
        final List<String> os = new ArrayList<>();
        final String score = "5.5";
        final CveModel cve = new CveModel(cveId, appList, summary, os, score);
        return cve;
    }

}
